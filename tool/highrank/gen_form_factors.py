#!/usr/bin/env python
# -*- coding: utf-8 -*-

# to run the tests, use
# python -m doctest gen_form_factors.py -v

import sys

name_prefix=""
reimplement_functions_enabled=False
reimplement_prefix="my_"

def get_all_fun(n, r):
    """get_all_fun(n,r)
       n: leg count
       r: rank

       >>> get_all_fun(3,5)
       [('a35', 5, 0), ('b35', 3, 2), ('c35', 1, 4)]
       >>> get_all_fun(1,0)
       [('a10', 0, 0)]
       >>> get_all_fun(6,0)
       [('a60', 0, 0)]
       >>> get_all_fun(6,4)
       [('a64', 4, 0)]

    """
    return [(chr(ord("a")+g) + ("%s%s" % (n,r)),r-2*g,2*g) for g in range(0,r/2+1 if n < 6 else 1) ]


def get_arglist(nargs, comma_after=True):
    """get_arglist(nargs)

       nargs: number of arguments

       >>> get_arglist(4)
       'l1,l2,l3,l4,'
       >>> get_arglist(4,False)
       'l1,l2,l3,l4'
       >>> get_arglist(0)
       ''
       >>> get_arglist(0,False)
       ''
    """
    if comma_after:
        return "".join(["l%s," % i for i in range(1,nargs+1)])
    else:
        return ",".join(["l%s" % i for i in range(1,nargs+1)])


def write_header(f, module_name, ranks):
    """
         write_header(f, ranks)

         f: output file
     ranks: dict of rank list per leg count
    """
    f.write("! vim:ts=3:sw=3\n")
    f.write("!\n")
    f.write("! THIS FILE IS AUTOGENERATED by %s.\n" % (__file__))
    f.write("! DO NOT CHANGE IT BY HAND.\n")
    f.write("!\n")
    f.write("!****h* src/higherrank/form_factor_higher_ranks\n")
    f.write("! NAME\n")
    f.write("!\n")
    f.write("!  Module form_factor_higher_ranks\n")
    f.write("!\n")
    f.write("! USAGE\n")
    f.write("!\n")
    f.write("!  use form_factor_higher_ranks\n")
    f.write("!\n")
    f.write("! DESCRIPTION\n")
    f.write("!\n")
    f.write("!  This module contains the form factors for one to six point amplitudes\n")
    f.write("!  where the rank is higher than the count of propagators\n")
    f.write("!\n")
    f.write("! OUTPUT\n")
    f.write("!\n")
    f.write("!  It exports functions:\n")
    for n in ranks:
        for r in ranks[n]:
            for fname,arg_count,dim in get_all_fun(n,r):
                first_letter = fname[0].upper()
                if r<=n:
                    if not reimplement_functions_enabled:
                        continue
                    fname = reimplement_prefix + fname
                else:
                    fname = name_prefix + fname
                f.write("!  * %s  -- a function to compute %s^{%s,%s}\n" % (fname, first_letter, n,r))
    f.write("!\n")
    f.write("!  Note that these are generic functions which can be called either with a\n")
    f.write("!  set of integers or with an integer whose bits represents the set\n")
    f.write("!\n")
    f.write("! USES\n")
    f.write("!\n")
    f.write("!  * precision (src/module/precision_golem.f90)\n")
    f.write("!  * matrice_s (src/kinematic/matrice_s.f90)\n")
    f.write("!  * array (src/module/array.f90)\n")
    f.write("!  * generic_function_np (src/highrank/generic_function_np.f90)\n")
    f.write("!  * constante (src/module/constante.f90)\n")
    f.write("!\n")
    f.write("!*****\n")

    f.write("module %s\n" % module_name)
    f.write("use %s, only: ki\n" % "precision_golem");
    libs = ["generic_function_np","form_factor_type","array"]

    for s in libs:
        f.write("use %s\n" % s)

    f.write("  implicit none\n")
    f.write("  private\n")

    for n in ranks:
        for r in ranks[n]:
            if r<=n:
                if not reimplement_functions_enabled:
                    continue
            f.write("!\n")
            for fname,arg_count,dim in get_all_fun(n,r):
                if r<=n:
                    fname = reimplement_prefix + fname
                else:
                    fname = name_prefix + fname
                f.write("  interface %s\n" % fname)
                f.write("    module procedure %s_b, %s_s\n" % (fname,fname))
                f.write("  end interface %s\n" % fname)
                f.write("  public :: %s\n" % fname)
            f.write("!\n!\n")
        f.write("!\n!\n")
    f.write("  integer, dimension(0) :: no_feynmanparam\n")
    f.write("  contains\n")

def write_footer(f, module_name):
    f.write("\n")
    f.write("end module %s\n" % module_name)


def write_formfactor(f,ranks):
    for n in ranks:
        for r in ranks[n]:
            f.write("\n")
            for fname,arg_count,dim in get_all_fun(n,r):
                if r<=n:
                    if not reimplement_functions_enabled:
                        continue
                    fname = reimplement_prefix + fname
                else:
                    fname = name_prefix + fname
                args=get_arglist(arg_count)
                args_wc=get_arglist(arg_count,False)

                f.write("  !****f* src/higherrank/form_factor_higher_ranks/%s_b\n" % (fname))
                f.write("  ! NAME\n")
                f.write("  !  type(form_factor) = %s_b(%sb_pin)\n" % (fname,args))
                f.write("  !\n")
                f.write("  ! DESCRIPTION\n")
                f.write("  !\n")
                f.write("  !  This function defines the form factor %s^{%s,%s}(%s).\n" % (fname[0].upper(),n,r,args_wc))
                f.write("  !\n")
                f.write("  ! INPUTS\n")
                f.write("  !\n")
                for i in range(1,arg_count+1):
                    f.write("  ! * l%s -- an integer corresponding to a label in the set of the remaining propagators\n" % i);
                f.write("  ! * b_pin -- an integer whose bits represent an array of integers of rank 1 corresponding \n")
                f.write("  !            to the label of the propagators pinched (removed from the original set\n")
                f.write("  !            which is in the global variable b_ref)\n")
                f.write("  !\n")
                f.write("  ! SIDE EFFECTS\n")
                f.write("  !\n")
                f.write("  !  It calls the function fnp_generic.\n")
                f.write("  !\n")
                f.write("  ! RETURN VALUE\n")
                f.write("  !\n")
                f.write("  !  The result returned is of the type form_factor\n")
                f.write("  !  It returns an array of three complex (type ki) corresponding\n")
                f.write("  !  to the real part, imaginary part of the coefficient in front 1/epsilon^2,\n")
                f.write("  !  the real part, imaginary part of the 1/epsilon term and the real part,\n")
                f.write("  !  imaginary part of the constant term.\n")
                f.write("  !\n")
                f.write("  !*****\n")
                f.write("  function %s_b(%sb_pin)\n" % (fname,args))
                f.write("   !\n")
                f.write("   integer, intent(in) :: %sb_pin\n" % args)
                f.write("   type(form_factor) :: %s_b\n" % fname)
                f.write("   !\n")
                if (r%2==0) and (dim==0):
                    f.write("   %s_b = fnp_generic(%s,%s,b_pin,%s,(/ %s /))\n" % (fname, n,dim,arg_count, args_wc if arg_count>0 else " integer:: " ))
                else:
                    f.write("   %s_b = %s_ki * fnp_generic(%s,%s,b_pin,%s,%s)\n" % (fname,(((-0.5)**(dim/2))*(-1)**r), n,dim,arg_count, ("(/ %s /)" % args_wc if arg_count>0 else "no_feynmanparam" )))
                f.write("   !\n")
                f.write("  end function %s_b\n" % (fname))
                f.write("\n")
                f.write("  !****f* src/higherrank/form_factor_higher_ranks/%s_s\n" % (fname))
                f.write("  ! NAME\n")
                f.write("  !  type(form_factor) = %s_s(%sset)\n" % (fname,args))
                f.write("  !\n")
                f.write("  ! DESCRIPTION\n")
                f.write("  !\n")
                f.write("  !  This function defines the form factor %s^{%s,%s}(%s).\n" % (fname[0].upper(),n,r,args_wc))
                f.write("  !\n")
                f.write("  ! INPUTS\n")
                f.write("  !\n")
                for i in range(1,arg_count+1):
                    f.write("  ! * l%s -- an integer corresponding to a label in the set of the remaining propagators\n" % i);
                f.write("  ! * set -- an array of integers of rank 1 corresponding to the label\n")
                f.write("  !          of the propagators pinched (removed from the original set\n")
                f.write("  !          which is in the global variable set_ref)\n")
                f.write("  !\n")
                f.write("  ! SIDE EFFECTS\n")
                f.write("  !\n")
                f.write("  !  It calls indirectly the function fnp_generic.\n")
                f.write("  !\n")
                f.write("  ! RETURN VALUE\n")
                f.write("  !\n")
                f.write("  !  The result returned is of the type form_factor\n")
                f.write("  !  It returns an array of three complex (type ki) corresponding\n")
                f.write("  !  to the real part, imaginary part of the coefficient in front 1/epsilon^2,\n")
                f.write("  !  the real part, imaginary part of the 1/epsilon term and the real part,\n")
                f.write("  !  imaginary part of the constant term.\n")
                f.write("  !\n")
                f.write("  !*****\n")

                f.write("  function %s_s(%sset)\n" % (fname,args))
                f.write("   !\n")
                f.write("   integer, intent (in), dimension(:) :: set\n")
                if arg_count>0:
                    f.write("   integer, intent(in) :: %s\n" % args_wc)
                f.write("   type(form_factor) :: %s_s\n" % fname)
                f.write("   !\n")
                f.write("   %s_s = %s_b(%spackb(set))\n" % (fname, fname, args))
                f.write("   !\n")
                f.write("  end function %s_s\n" % (fname))


if __name__ == "__main__":
   f=open("form_factor_higher_ranks.f90","w")
   module_name="form_factor_higher_ranks"
   ranks={}
   for n in range(1,7):
       if n>=5:
           ranks[n] = range(1,n+2)
       else:
           ranks[n] = range(1,n+11)
   if len(sys.argv)>1 and sys.argv[0]=="-m":
       enable_my_functions=True

   write_header(f,module_name,ranks)
   write_formfactor(f,ranks)
   write_footer(f,module_name)



# vim:ts=4:sw=4:expandtab
